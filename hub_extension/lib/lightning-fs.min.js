/**
 * Simplified LightningFS implementation for Chrome Extension
 * This provides minimal functionality needed for file operations
 * For a full implementation, download from: https://unpkg.com/@isomorphic-git/lightning-fs/dist/lightning-fs.min.js
 */
(function(global) {
  'use strict';
  
  class LightningFS {
    constructor(name) {
      this.name = name;
      this.storage = {};
      this.promises = this._createPromisesAPI();
      console.log(`[LightningFS] Created filesystem: ${name}`);
    }
    
    // Create promises-based API
    _createPromisesAPI() {
      return {
        mkdir: (path, options = {}) => {
          return new Promise((resolve, reject) => {
            try {
              this._mkdir(path, options);
              resolve();
            } catch (error) {
              reject(error);
            }
          });
        },
        
        readdir: (path, options = {}) => {
          return new Promise((resolve, reject) => {
            try {
              const result = this._readdir(path, options);
              resolve(result);
            } catch (error) {
              reject(error);
            }
          });
        },
        
        readFile: (path, options = {}) => {
          return new Promise((resolve, reject) => {
            try {
              const result = this._readFile(path, options);
              resolve(result);
            } catch (error) {
              reject(error);
            }
          });
        },
        
        writeFile: (path, data, options = {}) => {
          return new Promise((resolve, reject) => {
            try {
              this._writeFile(path, data, options);
              resolve();
            } catch (error) {
              reject(error);
            }
          });
        },
        
        unlink: (path) => {
          return new Promise((resolve, reject) => {
            try {
              this._unlink(path);
              resolve();
            } catch (error) {
              reject(error);
            }
          });
        },
        
        stat: (path) => {
          return new Promise((resolve, reject) => {
            try {
              const result = this._stat(path);
              resolve(result);
            } catch (error) {
              reject(error);
            }
          });
        },
        
        exists: (path) => {
          return new Promise((resolve) => {
            try {
              const exists = this._exists(path);
              resolve(exists);
            } catch (error) {
              resolve(false);
            }
          });
        }
      };
    }
    
    // Synchronous API implementations
    _normalizePath(path) {
      // Convert path to a standard format
      return path.replace(/\/+/g, '/').replace(/\/$/, '') || '/';
    }
    
    _parsePath(path) {
      path = this._normalizePath(path);
      const parts = path.split('/').filter(Boolean);
      return { parts, fullPath: '/' + parts.join('/') };
    }
    
    _getPathParts(path) {
      if (path === '/') return [];
      return this._parsePath(path).parts;
    }
    
    _mkdir(path, { recursive = false } = {}) {
      path = this._normalizePath(path);
      console.log(`[LightningFS] mkdir: ${path} (recursive: ${recursive})`);
      
      if (path === '/') return;
      
      const parts = this._getPathParts(path);
      let current = this.storage;
      
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (current[part] === undefined) {
          current[part] = { 
            type: 'dir',
            contents: {} 
          };
        } else if (current[part].type !== 'dir') {
          throw new Error(`ENOTDIR: not a directory, mkdir '${path}'`);
        }
        current = current[part].contents;
      }
    }
    
    _exists(path) {
      path = this._normalizePath(path);
      console.log(`[LightningFS] exists: ${path}`);
      
      try {
        this._stat(path);
        return true;
      } catch (error) {
        return false;
      }
    }
    
    _stat(path) {
      path = this._normalizePath(path);
      console.log(`[LightningFS] stat: ${path}`);
      
      if (path === '/') {
        return {
          type: 'dir',
          mode: 16877,
          size: 0,
          mtimeMs: Date.now(),
          isDirectory: () => true,
          isFile: () => false
        };
      }
      
      const parts = this._getPathParts(path);
      let current = this.storage;
      
      for (let i = 0; i < parts.length - 1; i++) {
        if (!current[parts[i]] || current[parts[i]].type !== 'dir') {
          throw new Error(`ENOENT: no such file or directory, stat '${path}'`);
        }
        current = current[parts[i]].contents;
      }
      
      const name = parts[parts.length - 1];
      if (!current[name]) {
        throw new Error(`ENOENT: no such file or directory, stat '${path}'`);
      }
      
      const item = current[name];
      return {
        type: item.type,
        mode: item.type === 'dir' ? 16877 : 33188,
        size: item.type === 'file' ? item.content.length : 0,
        mtimeMs: item.mtime || Date.now(),
        isDirectory: () => item.type === 'dir',
        isFile: () => item.type === 'file'
      };
    }
    
    _readdir(path, { withFileTypes = false } = {}) {
      path = this._normalizePath(path);
      console.log(`[LightningFS] readdir: ${path}`);
      
      let node;
      if (path === '/') {
        node = this.storage;
      } else {
        const parts = this._getPathParts(path);
        let current = this.storage;
        
        for (const part of parts) {
          if (!current[part] || current[part].type !== 'dir') {
            throw new Error(`ENOENT: no such file or directory, readdir '${path}'`);
          }
          current = current[part].contents;
        }
        
        node = current;
      }
      
      const entries = Object.keys(node);
      
      if (!withFileTypes) {
        return entries;
      }
      
      return entries.map(name => {
        const item = node[name];
        return {
          name,
          isDirectory: () => item.type === 'dir',
          isFile: () => item.type === 'file'
        };
      });
    }
    
    _readFile(path, { encoding = 'utf8' } = {}) {
      path = this._normalizePath(path);
      console.log(`[LightningFS] readFile: ${path}`);
      
      const parts = this._getPathParts(path);
      let current = this.storage;
      
      for (let i = 0; i < parts.length - 1; i++) {
        if (!current[parts[i]] || current[parts[i]].type !== 'dir') {
          throw new Error(`ENOENT: no such file or directory, open '${path}'`);
        }
        current = current[parts[i]].contents;
      }
      
      const name = parts[parts.length - 1];
      if (!current[name] || current[name].type !== 'file') {
        throw new Error(`ENOENT: no such file or directory, open '${path}'`);
      }
      
      return current[name].content;
    }
    
    _writeFile(path, data, { encoding = 'utf8' } = {}) {
      path = this._normalizePath(path);
      console.log(`[LightningFS] writeFile: ${path}`);
      
      const parts = this._getPathParts(path);
      
      // Make sure parent directories exist
      if (parts.length > 1) {
        const parentPath = '/' + parts.slice(0, -1).join('/');
        try {
          this._stat(parentPath);
        } catch (error) {
          this._mkdir(parentPath, { recursive: true });
        }
      }
      
      let current = this.storage;
      for (let i = 0; i < parts.length - 1; i++) {
        current = current[parts[i]].contents;
      }
      
      const name = parts[parts.length - 1];
      current[name] = {
        type: 'file',
        content: data,
        mtime: Date.now()
      };
    }
    
    _unlink(path) {
      path = this._normalizePath(path);
      console.log(`[LightningFS] unlink: ${path}`);
      
      const parts = this._getPathParts(path);
      let current = this.storage;
      
      for (let i = 0; i < parts.length - 1; i++) {
        if (!current[parts[i]] || current[parts[i]].type !== 'dir') {
          throw new Error(`ENOENT: no such file or directory, unlink '${path}'`);
        }
        current = current[parts[i]].contents;
      }
      
      const name = parts[parts.length - 1];
      if (!current[name]) {
        throw new Error(`ENOENT: no such file or directory, unlink '${path}'`);
      }
      
      delete current[name];
    }
  }
  
  // Export to global scope
  global.LightningFS = LightningFS;
  
})(typeof window !== 'undefined' ? window : this);